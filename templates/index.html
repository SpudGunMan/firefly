{% extends "base.html" %}

{% block title %}Chat - Firefly{% endblock %}

{% block content %}
<div class="row">
    <!-- Mobile-optimized profile controls -->
    <div class="col-12 d-md-none mb-2">
        <!-- Mobile compact profile bar -->
        <div class="d-flex gap-2 align-items-center" style="flex-wrap: nowrap;">
            <select id="profileSelect" class="form-select form-select-sm" style="min-width: 120px; flex: 1;">
                <option value="">Select profile...</option>
                {% for profile_id, profile in profiles.items() %}
                    <option value="{{ profile_id }}" {{ 'selected' if current_profile and current_profile.id == profile_id else '' }}>
                        {{ profile.long_name }}
                    </option>
                {% endfor %}
            </select>
            <button id="setProfileBtn" class="btn btn-primary btn-sm" style="white-space: nowrap;">Set</button>
            <a href="{{ url_for('profiles') }}" class="btn btn-outline-secondary btn-sm" style="white-space: nowrap;">Manage</a>
        </div>
    </div>
    
    <!-- Desktop sidebar -->
    <div class="col-lg-3 col-md-4 mb-3 d-none d-md-block">
        <div class="card">
            <div class="card-header">
                <h5>Profile Selection</h5>
            </div>
            <div class="card-body">
                <select id="profileSelectDesktop" class="form-select mb-2">
                    <option value="">Select a profile...</option>
                    {% for profile_id, profile in profiles.items() %}
                        <option value="{{ profile_id }}" {{ 'selected' if current_profile and current_profile.id == profile_id else '' }}>
                            {{ profile.long_name }}
                        </option>
                    {% endfor %}
                </select>
                
                <div class="d-grid gap-2">
                    <button id="setProfileBtnDesktop" class="btn btn-primary btn-sm">Set Profile</button>
                    <a href="{{ url_for('profiles') }}" class="btn btn-outline-secondary btn-sm">Manage Profiles</a>
                </div>
            </div>
        </div>
        
        <div class="card mt-3">
            <div class="card-header">
                <h6>Connection Status</h6>
            </div>
            <div class="card-body">
                <div class="mb-2">
                    <strong>WebSocket:</strong> <span id="connectionStatus" class="badge bg-secondary">Connecting...</span>
                </div>
                <div class="mb-2">
                    <strong>MUDP Interface:</strong> <span id="interfaceStatus" class="badge bg-warning">Not Started</span>
                </div>
                <div class="mt-2">
                    <small class="text-muted">Multicast: 224.0.0.69 • Port: 4403</small>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main chat area -->
    <div class="col-12 col-md-8 col-lg-9">
        <!-- Current Profile Banner - Mobile Compact -->
        <div id="currentProfileBanner" class="card mb-2 border-primary" style="display: none;">
            <div class="card-body bg-light py-2">
                <!-- Mobile compact layout -->
                <div class="d-md-none">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <strong class="text-primary" id="bannerProfileName">No Profile Selected</strong>
                        <span id="bannerInterfaceStatus" class="badge bg-warning">Not Connected</span>
                    </div>
                    <div class="small text-muted">
                        <span id="bannerChannel">-</span> • <span id="bannerNodeId">-</span> • <span id="bannerKey">-</span>
                    </div>
                </div>
                
                <!-- Desktop layout -->
                <div class="d-none d-md-block">
                    <div class="row align-items-center">
                        <div class="col-md-9">
                            <div class="d-flex flex-wrap align-items-center">
                                <strong class="text-primary me-3" id="bannerProfileNameDesktop">No Profile Selected</strong>
                                <div class="d-flex flex-wrap gap-2 small text-muted">
                                    <span>Node: <code class="bg-white px-1 rounded" id="bannerNodeIdDesktop">-</code></span>
                                    <span>•</span>
                                    <span>Channel: <strong id="bannerChannelDesktop">-</strong></span>
                                    <span>•</span>
                                    <span>Key: <code class="bg-white px-1 rounded" id="bannerKeyDesktop">-</code></span>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-3 text-end">
                            <div class="d-flex align-items-center justify-content-end">
                                <small class="text-muted me-2">Status:</small>
                                <span id="bannerInterfaceStatusDesktop" class="badge bg-warning">Not Connected</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card" style="overflow: hidden;">
            <div class="card-body p-0 d-flex flex-column" style="height: calc(100vh - 250px);">
                <div id="messagesContainer" class="flex-grow-1 p-3" style="overflow-y: auto; overflow-x: hidden; min-height: 200px;">
                    <!-- Messages will be populated here -->
                </div>
                
                <div class="p-3" style="border-top: 1px solid var(--bs-border-color-translucent);">
                    <div class="input-group mb-2">
                        <textarea id="messageInput" class="form-control" placeholder="Type your message..." maxlength="220" rows="2" style="resize: none;"></textarea>
                        <button id="sendBtn" class="btn btn-primary" type="button">Send</button>
                    </div>
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="form-text">Press Enter to send, Shift+Enter for new line.</div>
                        <small class="text-muted" id="charCount">0/220</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="mt-4">
    <div class="card">
        <div class="card-header">
            <h6 class="mb-0">
                <button class="btn btn-link p-0 text-decoration-none collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#instructionsCollapse" aria-expanded="false" aria-controls="instructionsCollapse">
                    <i class="fas fa-chevron-right me-1" id="instructionsIcon"></i> Instructions
                </button>
            </h6>
        </div>
        <div class="collapse" id="instructionsCollapse">
            <div class="card-body">
                <ul class="mb-0">
                    <li>Select or create a profile to start chatting</li>
                    <li>Messages are broadcast via UDP to the local network on port 4403</li>
                    <li>Anyone running this app on the same network can receive and send messages</li>
                    <li><strong>Mobile tip:</strong> Rotate your device to landscape for better chat experience</li>
                </ul>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<style>
/* Message text wrapping and overflow prevention */
#messagesContainer {
    overflow-x: hidden !important;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
}

.message {
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    max-width: 100%;
    overflow: hidden;
}

.message .flex-grow-1 {
    min-width: 0; /* Allows flex item to shrink below content size */
    word-wrap: break-word;
    overflow-wrap: break-word;
}

.message .mt-1 {
    word-wrap: break-word;
    overflow-wrap: break-word;
    white-space: pre-wrap; /* Preserve line breaks but allow wrapping */
    overflow-wrap: anywhere; /* Break anywhere if needed */
    hyphens: auto;
    max-width: 100%;
}

/* Handle long URLs and unbreakable content */
.message .mt-1 {
    /* Force break on very long words/URLs */
    word-break: break-all;
    overflow-wrap: anywhere;
}

/* Ensure sender info doesn't cause overflow */
.message strong,
.message small {
    word-wrap: break-word;
    overflow-wrap: break-word;
}

/* Handle URLs, links, and long strings specifically */
.message a,
.message code,
.message pre {
    word-break: break-all;
    overflow-wrap: anywhere;
    white-space: pre-wrap;
    max-width: 100%;
}

/* Handle Discord/Slack message URLs and long identifiers */
.message .mt-1:contains('http'),
.message .mt-1:contains('discord.com'),
.message .mt-1:contains('://') {
    word-break: break-all;
    overflow-wrap: anywhere;
}

/* Fallback for any remaining overflow issues */
.d-flex.justify-content-between.align-items-start {
    min-width: 0;
    width: 100%;
}

.d-flex.justify-content-between.align-items-start > * {
    min-width: 0;
}

/* Message input textarea styling */
#messageInput {
    resize: none;
    transition: height 0.2s ease;
    line-height: 1.4;
    font-family: inherit;
}

/* Character count styling */
#charCount {
    font-size: 0.75rem;
    font-weight: 500;
}

/* Chat layout improvements */
.card-body.d-flex.flex-column {
    height: calc(100vh - 250px);
    min-height: 350px;
}

#messagesContainer {
    background: inherit;
    border: none;
    border-radius: 0;
}

/* Remove default margins that might cause issues */
.card-body.p-0 {
    padding: 0 !important;
}

/* Ensure no unwanted borders in messages area */
#messagesContainer {
    border-top: none !important;
    border-bottom: none !important;
}

/* Mobile compact profile controls */
@media (max-width: 767.98px) {
    .container {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }
    
    /* Compact profile banner on mobile */
    #currentProfileBanner .card-body {
        padding: 0.5rem !important;
    }
    
    #currentProfileBanner {
        margin-bottom: 0.5rem !important;
    }
    
    /* Mobile chat container - leave space for text entry */
    .card-body.d-flex.flex-column {
        height: calc(100vh - 200px) !important;
        min-height: 200px !important;
    }
    
    .card {
        margin-bottom: 0.5rem;
    }
    
    /* Extra aggressive text wrapping on mobile */
    .message .mt-1 {
        word-break: break-word;
        overflow-wrap: anywhere;
        line-break: anywhere;
    }
    
    /* Compact mobile profile controls */
    .d-flex.gap-2.align-items-center {
        gap: 0.5rem !important;
    }
    
    /* Make buttons more compact */
    .btn-sm {
        padding: 0.25rem 0.5rem;
        font-size: 0.775rem;
    }
    
    /* Message input area styling - more compact on mobile */
    #messageInput {
        max-height: 60px;
        min-height: 34px;
        line-height: 1.2;
        font-size: 0.9rem;
    }
    
    /* Compact input group on mobile */
    .input-group .btn {
        padding: 0.375rem 0.75rem;
    }
    
    /* Reduce padding in input area */
    .card-body > div:last-child {
        padding: 0.75rem !important;
    }
    
    .input-group.mb-2 {
        margin-bottom: 0.5rem !important;
    }
}

/* Extra small screens - make buttons even more compact */
@media (max-width: 375px) {
    .d-md-none .btn-sm {
        padding: 0.2rem 0.4rem;
        font-size: 0.7rem;
    }
    
    .d-md-none .form-select-sm {
        font-size: 0.775rem;
    }
    
    .d-md-none .gap-2 {
        gap: 0.25rem !important;
    }
}

/* Ensure notifications are visible on mobile */
@media (max-width: 576px) {
    .alert.position-fixed {
        top: 10px !important;
        right: 10px !important;
        left: 10px !important;
        max-width: none !important;
    }
}
</style>
<script>
// Chat-specific JavaScript
console.log('[page] index.js inline loaded');
let currentProfile = null;
let socket = null;

document.addEventListener('DOMContentLoaded', function() {
    // Initialize WebSocket connection (don’t block the rest of the UI if this fails)
    try {
        if (typeof io !== 'undefined') {
            initializeSocket();
        } else {
            throw new Error('socket.io-client not loaded');
        }
    } catch (e) {
        console.error('[socket] init failed:', e);
        const badge = document.getElementById('connectionStatus');
        if (badge) {
            badge.className = 'badge bg-danger';
            badge.textContent = 'Socket error';
        }
    }
    
    // Load current profile and ensure banner is updated
    loadCurrentProfile();
    
    // Load current interface status
    loadInterfaceStatus();
    
    // Ensure banner stays updated (check every 30 seconds)
    setInterval(refreshProfileBanner, 30000);
    
    // Set up event listeners first so the UI is interactive immediately
    document.getElementById('setProfileBtn').addEventListener('click', setProfile);
    const desktopBtn = document.getElementById('setProfileBtnDesktop');
    if (desktopBtn) {
        desktopBtn.addEventListener('click', setProfile);
    }
    document.getElementById('sendBtn').addEventListener('click', sendMessage);
    const messageInput = document.getElementById('messageInput');
    
    // Handle Enter/Shift+Enter key combinations
    messageInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            if (e.shiftKey) {
                // Shift+Enter: Allow newline (default behavior)
                return;
            } else {
                // Enter alone: Send message
                e.preventDefault();
                sendMessage();
            }
        }
    });
    
    // Character counting
    messageInput.addEventListener('input', function() {
        const charCount = document.getElementById('charCount');
        const currentLength = this.value.length;
        charCount.textContent = `${currentLength}/220`;
        
        // Change color when approaching limit
        if (currentLength > 200) {
            charCount.className = 'text-warning';
        } else if (currentLength === 220) {
            charCount.className = 'text-danger';
        } else {
            charCount.className = 'text-muted';
        }
    });
    
    // Handle instructions collapse icon rotation
    const instructionsCollapse = document.getElementById('instructionsCollapse');
    const instructionsIcon = document.getElementById('instructionsIcon');
    if (instructionsCollapse && instructionsIcon) {
        instructionsCollapse.addEventListener('show.bs.collapse', function() {
            instructionsIcon.className = 'fas fa-chevron-down me-1';
        });
        instructionsCollapse.addEventListener('hide.bs.collapse', function() {
            instructionsIcon.className = 'fas fa-chevron-right me-1';
        });
    }

    // Now load existing messages (non-blocking)
    loadMessages();
    
});

function initializeSocket() {
    socket = io();

    socket.on('connect', function() {
        console.log('[socket] connected');
        document.getElementById('connectionStatus').className = 'badge bg-success';
        document.getElementById('connectionStatus').textContent = 'Connected';
        
        // Join channel room if we have a current profile
        if (currentProfile && currentProfile.channel && currentProfile.key) {
            joinChannelRoom(currentProfile);
        }
    });

    socket.on('connect_error', function(err) {
        console.error('[socket] connect_error', err);
        document.getElementById('connectionStatus').className = 'badge bg-danger';
        document.getElementById('connectionStatus').textContent = 'Connect error';
    });

    socket.on('reconnect_attempt', function(n) {
        console.warn('[socket] reconnect_attempt', n);
        document.getElementById('connectionStatus').className = 'badge bg-warning';
        document.getElementById('connectionStatus').textContent = 'Reconnecting…';
    });

    socket.on('disconnect', function(reason) {
        console.warn('[socket] disconnected', reason);
        document.getElementById('connectionStatus').className = 'badge bg-danger';
        document.getElementById('connectionStatus').textContent = 'Disconnected';
    });

    socket.on('new_message', function(message) {
        addMessageToUI(message);
    });
    
    // Handle profile switch notifications
    socket.on('profile_switched', function(data) {
        console.log('[socket] profile_switched:', data);
        if (data.loaded_messages > 0) {
            showNotification(
                `Switched to ${data.profile_name} (${data.profile_channel}). Loaded ${data.loaded_messages} missed message(s) from channel ${data.channel_number}.`,
                'success',
                5000
            );
        } else {
            showNotification(
                `Switched to ${data.profile_name} (${data.profile_channel}). No missed messages.`,
                'info',
                3000
            );
        }
    });
    
    socket.on('node_update', function(data) {
        console.log('[socket] node update:', data);
        
        // Show notification for new nodes or significant changes
        if (data.is_new) {
            showNodeNotification(`New node discovered: ${data.long_name} (${data.short_name})`, 'success');
        } else if (data.changes && data.changes.length > 0) {
            showNodeNotification(`Node updated: ${data.long_name} - ${data.changes.length} change(s)`, 'info');
        }
        
    });
}

function loadCurrentProfile() {
    fetch('/api/current-profile')
        .then(response => response.json())
        .then(profile => {
            currentProfile = profile;
            if (profile) {
                // Sync both mobile and desktop selectors
                const mobileSelect = document.getElementById('profileSelect');
                const desktopSelect = document.getElementById('profileSelectDesktop');
                if (mobileSelect) mobileSelect.value = profile.id;
                if (desktopSelect) desktopSelect.value = profile.id;
            }
            // Update banner with profile info (status will sync from sidebar)
            updateProfileBanner(profile);
        })
        .catch(error => console.error('Error loading current profile:', error));
}

function loadInterfaceStatus() {
    // Load the current interface status from API
    fetch('/api/current-profile')
        .then(response => response.json())
        .then(profile => {
            if (profile && profile.id) {
                // Profile is set - check interface status from API
                const interfaceStatus = profile.interface_status;
                
                if (interfaceStatus === 'started') {
                    updateInterfaceStatus('bg-success', 'Connected');
                } else if (interfaceStatus === 'failed') {
                    updateInterfaceStatus('bg-danger', 'Failed to Start');
                } else if (interfaceStatus === 'stopped') {
                    updateInterfaceStatus('bg-secondary', 'Stopped');
                } else {
                    updateInterfaceStatus('bg-warning', 'Not Started');
                }
                
                // Profile banner is updated separately by updateProfileBanner()
                
                console.log('[STATUS] Interface status loaded:', interfaceStatus, 'for profile', profile.long_name);
            } else {
                // No profile set - interface not started
                updateInterfaceStatus('bg-warning', 'Not Started');
                
                // Profile banner will be hidden by updateProfileBanner()
                
                console.log('[STATUS] Interface status loaded: Not Started (no profile)');
            }
        })
        .catch(error => {
            console.error('Error loading interface status:', error);
            // Default to unknown status if we can't determine
            updateInterfaceStatus('bg-secondary', 'Unknown');
        });
}

function updateInterfaceStatus(status, statusText) {
    // Update both sidebar and banner interface status simultaneously
    const sidebarStatus = document.getElementById('interfaceStatus');
    const bannerStatus = document.getElementById('bannerInterfaceStatus');
    
    const statusClass = `badge ${status}`;
    
    if (sidebarStatus) {
        sidebarStatus.className = statusClass;
        sidebarStatus.textContent = statusText;
    }
    
    if (bannerStatus) {
        bannerStatus.className = statusClass;
        bannerStatus.textContent = statusText;
    }
    
    console.log('[STATUS] Interface status updated:', statusText, status);
}

function updateProfileBanner(profile) {
    const banner = document.getElementById('currentProfileBanner');
    
    // Mobile elements
    const profileName = document.getElementById('bannerProfileName');
    const nodeId = document.getElementById('bannerNodeId');
    const channel = document.getElementById('bannerChannel');
    const key = document.getElementById('bannerKey');
    const interfaceStatus = document.getElementById('bannerInterfaceStatus');
    
    // Desktop elements
    const profileNameDesktop = document.getElementById('bannerProfileNameDesktop');
    const nodeIdDesktop = document.getElementById('bannerNodeIdDesktop');
    const channelDesktop = document.getElementById('bannerChannelDesktop');
    const keyDesktop = document.getElementById('bannerKeyDesktop');
    const interfaceStatusDesktop = document.getElementById('bannerInterfaceStatusDesktop');
    
    if (profile) {
        // Show and populate banner
        banner.style.display = 'block';
        
        const profileLongName = profile.long_name || 'Unknown Profile';
        const profileNodeId = profile.node_id || 'Unknown';
        const profileChannel = profile.channel || 'Unknown';
        
        // Show truncated key for security
        const profileKey = profile.key || '';
        const truncatedKey = profileKey.length > 8 ? profileKey.substring(0, 8) + '...' : (profileKey || 'No Key');
        
        // Update mobile elements
        if (profileName) profileName.textContent = profileLongName;
        if (nodeId) nodeId.textContent = profileNodeId;
        if (channel) channel.textContent = profileChannel;
        if (key) key.textContent = truncatedKey;
        
        // Update desktop elements
        if (profileNameDesktop) profileNameDesktop.textContent = profileLongName;
        if (nodeIdDesktop) nodeIdDesktop.textContent = profileNodeId;
        if (channelDesktop) channelDesktop.textContent = profileChannel;
        if (keyDesktop) keyDesktop.textContent = truncatedKey;
        
        // Sync interface status with sidebar status
        const sidebarInterfaceStatus = document.getElementById('interfaceStatus');
        if (sidebarInterfaceStatus && sidebarInterfaceStatus.textContent) {
            const statusClass = sidebarInterfaceStatus.className;
            const statusText = sidebarInterfaceStatus.textContent;
            
            if (interfaceStatus) {
                interfaceStatus.className = statusClass;
                interfaceStatus.textContent = statusText;
            }
            if (interfaceStatusDesktop) {
                interfaceStatusDesktop.className = statusClass;
                interfaceStatusDesktop.textContent = statusText;
            }
        }
        
        console.log('[BANNER] Updated with profile:', profile.long_name);
    } else {
        // Hide banner when no profile
        banner.style.display = 'none';
        console.log('[BANNER] Hidden - no profile selected');
    }
}

function refreshProfileBanner() {
    // Refresh the banner with current profile to ensure it stays visible
    // Don't override interface status - let it stay as set by setProfile
    if (currentProfile) {
        updateProfileBanner(currentProfile);
    }
}

// Channel room management for WebSocket
let currentChannelRoom = null;

function calculateChannelHash(channelName, key) {
    // This is a simple hash function - ideally should match the server-side logic
    // For now, we'll get the channel number from the profile switching response
    return null; // Will be set by server response
}

function joinChannelRoom(profile) {
    if (!socket || !profile) return;
    
    // Calculate channel number (we'll get this from the server response instead)
    // For now, just emit the join request with channel name and key
    socket.emit('join_channel', {
        channel_name: profile.channel,
        key: profile.key
    });
    console.log('[socket] requested to join channel room for:', profile.channel);
}

function leaveCurrentChannelRoom() {
    if (!socket || !currentChannelRoom) return;
    
    socket.emit('leave_channel', {
        channel: currentChannelRoom
    });
    console.log('[socket] left channel room:', currentChannelRoom);
    currentChannelRoom = null;
}


function loadMessages() {
    fetch('/api/messages')
        .then(response => response.json())
        .then(list => {
            const container = document.getElementById('messagesContainer');
            if (!container) return;
            container.innerHTML = '';
            (list || []).forEach(addMessageToUI);
            
        })
        .catch(err => {
            console.error('Error loading messages:', err);
            // Do not throw; we still want the rest of the page JS to run
        });
}

function setProfile(event) {
    // Determine which button was clicked
    const clickedButton = event ? event.target : null;
    const isDesktopButton = clickedButton && clickedButton.id === 'setProfileBtnDesktop';
    
    // Get profile ID from the appropriate selector
    let profileId = '';
    let setBtn = null;
    
    if (isDesktopButton) {
        // Desktop button clicked - use desktop selector
        const desktopSelect = document.getElementById('profileSelectDesktop');
        profileId = desktopSelect ? desktopSelect.value : '';
        setBtn = document.getElementById('setProfileBtnDesktop');
    } else {
        // Mobile button clicked or fallback - use mobile selector
        const mobileSelect = document.getElementById('profileSelect');
        profileId = mobileSelect ? mobileSelect.value : '';
        setBtn = document.getElementById('setProfileBtn');
    }
    
    if (!setBtn) {
        console.error('[PROFILE] No set button found');
        return;
    }
    
    console.log('[PROFILE] Using', isDesktopButton ? 'desktop' : 'mobile', 'selector with value:', profileId);
    
    // Show loading state
    setBtn.disabled = true;
    setBtn.textContent = 'Setting Profile...';
    
    fetch('/api/current-profile', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ profile_id: profileId || null })
    })
    .then(response => {
        console.log('[PROFILE] Response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('[PROFILE] Response data:', data);
        if (data.error) {
            alert('Error: ' + data.error);
        } else {
            // Leave current channel room before switching
            leaveCurrentChannelRoom();
            
            currentProfile = data.profile || null;
            
            // Join new channel room if profile is set
            if (currentProfile && socket) {
                // We'll get the channel number from the server response if available
                if (data.channel_number !== undefined) {
                    currentChannelRoom = data.channel_number;
                    socket.emit('join_channel', { channel: currentChannelRoom });
                    console.log('[socket] joined channel room:', currentChannelRoom);
                }
            }
            
            // Update profile banner
            updateProfileBanner(currentProfile);
            
            // Clear and reload messages with profile-specific messages
            const container = document.getElementById('messagesContainer');
            if (container) {
                container.innerHTML = '';
            }
            if (currentProfile && data.messages && Array.isArray(data.messages)) {
                console.log(`[PROFILE] Loading ${data.messages.length} messages for profile: ${currentProfile.long_name}`);
                data.messages.forEach(addMessageToUI);
            } else if (!currentProfile) {
                console.log('[PROFILE] No profile selected - messages cleared');
            } else {
                console.log('[PROFILE] No messages returned for profile');
            }
            
            // Update interface status in both sidebar and banner
            if (data.interface_status === 'started') {
                updateInterfaceStatus('bg-success', 'Connected');
                // Profile banner already updated by updateProfileBanner() call above
            } else if (data.interface_status === 'failed') {
                updateInterfaceStatus('bg-danger', 'Failed to Start');
                if (data.warning) {
                    alert('Warning: ' + data.warning);
                }
            } else if (data.interface_status === 'stopped') {
                updateInterfaceStatus('bg-secondary', 'Stopped');
            } else {
                updateInterfaceStatus('bg-warning', 'Not Started');
            }
            
            
            // Show profile switch notification with unread message count
            console.log('[NOTIFICATION] Debug: currentProfile =', currentProfile);
            console.log('[NOTIFICATION] Debug: data.unread_count =', data.unread_count);
            console.log('[NOTIFICATION] Debug: condition check:', currentProfile && data.unread_count !== undefined);
            
            if (currentProfile && data.unread_count !== undefined) {
                console.log('[NOTIFICATION] Showing notification with unread count:', data.unread_count);
                
                if (data.unread_count > 0) {
                    console.log('[NOTIFICATION] Showing success notification for', data.unread_count, 'unread messages');
                    showNotification(
                        `Switched to ${currentProfile.long_name} (${currentProfile.channel}). ${data.unread_count} unread message${data.unread_count === 1 ? '' : 's'} loaded.`,
                        'success',
                        5000
                    );
                } else {
                    console.log('[NOTIFICATION] Showing info notification for no unread messages');
                    showNotification(
                        `Switched to ${currentProfile.long_name} (${currentProfile.channel}). No unread messages.`,
                        'info',
                        3000
                    );
                }
            } else {
                console.log('[NOTIFICATION] NOT showing notification - condition failed');
            }
            
            console.log('[PROFILE] ✅ Profile set successfully!');
            console.log('[PROFILE] Interface status updated:', data.interface_status);
            console.log('[PROFILE] Banner updated for profile:', currentProfile?.long_name);
            console.log('[PROFILE] Messages loaded:', data.messages ? data.messages.length : 0);
            console.log('[PROFILE] Unread messages:', data.unread_count || 0);
        }
    })
    .catch(error => {
        console.error('Error setting profile:', error);
        console.error('Error details:', {
            message: error.message,
            stack: error.stack,
            profileId: profileId
        });
        
        // Check if the profile was actually set despite the error
        fetch('/api/current-profile')
            .then(response => response.json())
            .then(profile => {
                if (profile && profile.id === profileId) {
                    console.log('[PROFILE] Profile was actually set despite error, updating UI');
                    currentProfile = profile;
                    updateProfileBanner(profile);
                    // Don't show error popup if profile was set successfully
                    console.warn('[PROFILE] Suppressing error popup since profile was set');
                } else {
                    // Profile wasn't set, show the error
                    alert('Error setting profile: ' + error.message);
                }
            })
            .catch(() => {
                // If we can't check current profile, show the original error
                alert('Error setting profile: ' + error.message);
            });
    })
    .finally(() => {
        // Reset the specific button that was used
        if (setBtn) {
            setBtn.disabled = false;
            if (setBtn.id === 'setProfileBtnDesktop') {
                setBtn.textContent = 'Set Profile';
            } else {
                setBtn.textContent = 'Set';
            }
        }
    });
}

async function sendMessage() {
    const btn = document.getElementById('sendBtn');
    const messageInput = document.getElementById('messageInput');
    const message = messageInput.value.trim();
    if (!message) return;
    if (!currentProfile) { alert('Please select a profile first'); return; }
    
    // Check message length
    if (message.length > 220) {
        alert('Message is too long. Maximum 220 characters allowed.');
        return;
    }
    
    btn.disabled = true;
    try {
        const response = await fetch('/api/send-message', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
        });
        const data = await response.json().catch(() => ({ error: 'Invalid JSON response' }));
        if (!response.ok) throw new Error(data.error || ('HTTP ' + response.status));
        messageInput.value = '';
        
        // Reset character counter
        const charCount = document.getElementById('charCount');
        if (charCount) {
            charCount.textContent = '0/220';
            charCount.className = 'text-muted';
        }
    } catch (err) {
        console.error('Error sending message:', err);
        alert('Error sending message: ' + err.message);
    } finally {
        btn.disabled = false;
        messageInput.focus();
    }
}

function addMessageToUI(message) {
    const container = document.getElementById('messagesContainer');
    const messageEl = document.createElement('div');
    messageEl.className = 'message mb-2 p-2 border-bottom';
    
    // Handle timestamp - ensure UTC timestamps are properly converted to local time
    let timestamp = '';
    if (message && message.timestamp) {
        try {
            let ts;
            const rawTimestamp = message.timestamp;
            
            // Convert to Date object based on different possible formats
            if (typeof rawTimestamp === 'number') {
                // Unix timestamp (milliseconds or seconds)
                ts = rawTimestamp > 1e10 ? new Date(rawTimestamp) : new Date(rawTimestamp * 1000);
            } else if (typeof rawTimestamp === 'string') {
                // String timestamp - multiple formats possible
                const tsString = rawTimestamp.trim();
                
                if (tsString.includes('T') && (tsString.includes('Z') || tsString.includes('+') || tsString.includes('-'))) {
                    // ISO 8601 with timezone info
                    ts = new Date(tsString);
                } else if (tsString.includes('T')) {
                    // ISO format without timezone - assume UTC
                    ts = new Date(tsString + 'Z');
                } else if (tsString.match(/^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/)) {
                    // SQL datetime format "YYYY-MM-DD HH:MM:SS" - assume UTC
                    ts = new Date(tsString.replace(' ', 'T') + 'Z');
                } else {
                    // Try parsing as-is and assume UTC if no timezone
                    ts = new Date(tsString);
                    if (isNaN(ts.getTime())) {
                        // If that fails, try adding Z
                        ts = new Date(tsString + 'Z');
                    }
                }
            } else {
                // Fallback for other types
                ts = new Date(rawTimestamp);
            }
            
            if (!isNaN(ts.getTime())) {
                timestamp = ts.toLocaleTimeString([], {hour12: true, hour: 'numeric', minute: '2-digit'});
            }
        } catch (e) {
            console.warn('[TIMESTAMP] Error parsing timestamp:', message.timestamp, e);
        }
    }
    const isOwnMessage = message.sender_ip === 'self';
    
    messageEl.innerHTML = `
        <div class="d-flex justify-content-between align-items-start">
            <div class="flex-grow-1">
                <strong class="${isOwnMessage ? 'text-primary' : 'text-info'}">${escapeHtml(message.sender_display)}</strong>
                <small class="text-muted">(${escapeHtml(message.sender)})</small>
                ${isOwnMessage ? '<span class="badge bg-primary ms-1">You</span>' : ''}
                <div class="mt-1">${escapeHtml(message.content).replace(/\n/g, '<br>')}</div>
            </div>
            <small class="text-muted">${timestamp}</small>
        </div>
    `;
    
    container.appendChild(messageEl);
    container.scrollTop = container.scrollHeight;
}


function showNodeNotification(message, type = 'info') {
    // Create a temporary notification element
    const notification = document.createElement('div');
    notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 300px;';
    notification.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

function showNotification(message, type = 'info', duration = 4000) {
    console.log('[NOTIFICATION] showNotification called:', { message, type, duration });
    // Create a temporary notification element
    const notification = document.createElement('div');
    notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
    notification.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(notification);
    console.log('[NOTIFICATION] Toast notification displayed');
    
    // Auto-remove after specified duration
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, duration);
}

function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
</script>
{% endblock %}
